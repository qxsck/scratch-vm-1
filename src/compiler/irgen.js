const Cast = require('../util/cast');
const StringUtil = require('../util/string-util');
const BlockType = require('../extension-support/block-type');
const Variable = require('../engine/variable');
const log = require('../util/log');
const {IntermediateScript, IntermediateRepresentation} = require('./intermediate');
const compatBlocks = require('./compat-blocks');
const {BlockOpcode, ReporterOpcode} = require('./enums.js')

/**
 * @fileoverview Generate intermediate representations from Scratch blocks.
 */

const SCALAR_TYPE = '';
const LIST_TYPE = 'list';

/**
 * @typedef {Object.<string, *>} Node
 * @property {string} kind
 */

/**
 * Create a variable codegen object.
 * @param {'target'|'stage'} scope The scope of this variable -- which object owns it.
 * @param {import('../engine/variable.js')} varObj The Scratch Variable
 * @returns {*} A variable codegen object.
 */
const createVariableData = (scope, varObj) => ({
    scope,
    id: varObj.id,
    name: varObj.name,
    isCloud: varObj.isCloud
});

/**
 * @param {string} code
 * @param {boolean} warp
 * @returns {string}
 */
const generateProcedureVariant = (code, warp) => {
    if (warp) {
        return `W${code}`;
    }
    return `Z${code}`;
};

/**
 * @param {string} variant Variant generated by generateProcedureVariant()
 * @returns {string} original procedure code
 */
const parseProcedureCode = variant => variant.substring(1);

/**
 * @param {string} variant Variant generated by generateProcedureVariant()
 * @returns {boolean} true if warp enabled
 */
const parseIsWarp = variant => variant.charAt(0) === 'W';

class ScriptTreeGenerator {
    constructor (thread) {
        /** @private */
        this.thread = thread;
        /** @private */
        this.target = thread.target;
        /** @private */
        this.blocks = thread.blockContainer;
        /** @private */
        this.runtime = this.target.runtime;
        /** @private */
        this.stage = this.runtime.getTargetForStage();

        /**
         * This script's intermediate representation.
         */
        this.script = new IntermediateScript();
        this.script.warpTimer = this.target.runtime.compilerOptions.warpTimer;

        /**
         * Cache of variable ID to variable data object.
         * @type {Object.<string, object>}
         * @private
         */
        this.variableCache = {};

        this.usesTimer = false;
    }

    setProcedureVariant (procedureVariant) {
        const procedureCode = parseProcedureCode(procedureVariant);

        this.script.procedureCode = procedureCode;
        this.script.isProcedure = true;
        this.script.yields = false;

        const paramNamesIdsAndDefaults = this.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
        if (paramNamesIdsAndDefaults === null) {
            throw new Error(`IR: cannot find procedure: ${procedureVariant}`);
        }

        const [paramNames, _paramIds, _paramDefaults] = paramNamesIdsAndDefaults;
        this.script.arguments = paramNames;
    }

    enableWarp () {
        this.script.isWarp = true;
    }

    getBlockById (blockId) {
        // Flyout blocks are stored in a special container.
        return this.blocks.getBlock(blockId) || this.blocks.runtime.flyoutBlocks.getBlock(blockId);
    }

    getBlockInfo (fullOpcode) {
        const [category, opcode] = StringUtil.splitFirst(fullOpcode, '_');
        if (!category || !opcode) {
            return null;
        }
        const categoryInfo = this.runtime._blockInfo.find(ci => ci.id === category);
        if (!categoryInfo) {
            return null;
        }
        const blockInfo = categoryInfo.blocks.find(b => b.info.opcode === opcode);
        if (!blockInfo) {
            return null;
        }
        return blockInfo;
    }

    /**
     * Descend into a child input of a block. (eg. the input STRING of "length of ( )")
     * @param {*} parentBlock The parent Scratch block that contains the input.
     * @param {string} inputName The name of the input to descend into.
     * @private
     * @returns {Node} Compiled input node for this input.
     */
    descendInputOfBlock (parentBlock, inputName) {
        const input = parentBlock.inputs[inputName];
        if (!input) {
            log.warn(`IR: ${parentBlock.opcode}: missing input ${inputName}`, parentBlock);
            return {
                kind: ReporterOpcode.CONSTANT,
                value: 0
            };
        }
        const inputId = input.block;
        const block = this.getBlockById(inputId);
        if (!block) {
            log.warn(`IR: ${parentBlock.opcode}: could not find input ${inputName} with ID ${inputId}`);
            return {
                kind: ReporterOpcode.CONSTANT,
                value: 0
            };
        }

        return this.descendInput(block);
    }

    /**
     * Descend into an input. (eg. "length of ( )")
     * @param {*} block The parent Scratch block input.
     * @private
     * @returns {Node} Compiled input node for this input.
     */
    descendInput (block) {
        switch (block.opcode) {
        case 'colour_picker':
            return {
                kind: ReporterOpcode.CONSTANT,
                value: block.fields.COLOUR.value
            };
        case 'math_angle':
        case 'math_integer':
        case 'math_number':
        case 'math_positive_number':
        case 'math_whole_number':
            return {
                kind: ReporterOpcode.CONSTANT,
                value: block.fields.NUM.value
            };
        case 'text':
            return {
                kind: ReporterOpcode.CONSTANT,
                value: block.fields.TEXT.value
            };

        case 'argument_reporter_string_number': {
            const name = block.fields.VALUE.value;
            // lastIndexOf because multiple parameters with the same name will use the value of the last definition
            const index = this.script.arguments.lastIndexOf(name);
            if (index === -1) {
                // Legacy support
                if (name.toLowerCase() === 'last key pressed') {
                    return {
                        kind: ReporterOpcode.TW_KEY_LAST_PRESSED,
                    };
                }
            }
            if (index === -1) {
                return {
                    kind: ReporterOpcode.CONSTANT,
                    value: 0
                };
            }
            return {
                kind: ReporterOpcode.PROCEDURE_ARG_STRING_NUMBER,
                index: index
            };
        }
        case 'argument_reporter_boolean': {
            // see argument_reporter_string_number above
            const name = block.fields.VALUE.value;
            const index = this.script.arguments.lastIndexOf(name);
            if (index === -1) {
                if (name.toLowerCase() === 'is compiled?' || name.toLowerCase() === 'is turbowarp?') {
                    return {
                        kind: ReporterOpcode.CONSTANT,
                        value: true
                    };
                }
                return {
                    kind: ReporterOpcode.CONSTANT,
                    value: 0
                };
            }
            return {
                kind: ReporterOpcode.PROCEDURE_ARG_BOOLEAN,
                index: index
            };
        }

        case 'data_variable':
            return {
                kind: ReporterOpcode.VAR_GET,
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
            };
        case 'data_itemoflist':
            return {
                kind: ReporterOpcode.LIST_GET,
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: this.descendInputOfBlock(block, 'INDEX')
            };
        case 'data_lengthoflist':
            return {
                kind: ReporterOpcode.LIST_LENGTH,
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            };
        case 'data_listcontainsitem':
            return {
                kind: ReporterOpcode.LIST_CONTAINS,
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                item: this.descendInputOfBlock(block, 'ITEM')
            };
        case 'data_itemnumoflist':
            return {
                kind: ReporterOpcode.LIST_INDEX_OF,
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                item: this.descendInputOfBlock(block, 'ITEM')
            };
        case 'data_listcontents':
            return {
                kind: ReporterOpcode.LIST_CONTENTS,
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            };

        case 'event_broadcast_menu': {
            const broadcastOption = block.fields.BROADCAST_OPTION;
            const broadcastVariable = this.target.lookupBroadcastMsg(broadcastOption.id, broadcastOption.value);
            // TODO: empty string probably isn't the correct fallback
            const broadcastName = broadcastVariable ? broadcastVariable.name : '';
            return {
                kind: ReporterOpcode.CONSTANT,
                value: broadcastName
            };
        }

        case 'looks_backdropnumbername':
            if (block.fields.NUMBER_NAME.value === 'number') {
                return {
                    kind: ReporterOpcode.LOOKS_BACKDROP_NUMBER
                };
            }
            return {
                kind: ReporterOpcode.LOOKS_BACKDROP_NAME
            };
        case 'looks_costumenumbername':
            if (block.fields.NUMBER_NAME.value === 'number') {
                return {
                    kind: ReporterOpcode.LOOKS_COSTUME_NUMBER
                };
            }
            return {
                kind: ReporterOpcode.LOOKS_COSTUME_NAME
            };
        case 'looks_size':
            return {
                kind: ReporterOpcode.LOOKS_SIZE_GET,
            };

        case 'motion_direction':
            return {
                kind: ReporterOpcode.MOTION_DIRECTION_GET,
            };
        case 'motion_xposition':
            return {
                kind: ReporterOpcode.MOTION_X_GET,
            };
        case 'motion_yposition':
            return {
                kind: ReporterOpcode.MOTION_Y_GET,
            };

        case 'operator_add':
            return {
                kind: ReporterOpcode.OP_ADD,
                left: this.descendInputOfBlock(block, 'NUM1'),
                right: this.descendInputOfBlock(block, 'NUM2')
            };
        case 'operator_and':
            return {
                kind: ReporterOpcode.OP_AND,
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            };
        case 'operator_contains':
            return {
                kind: ReporterOpcode.OP_CONTAINS,
                string: this.descendInputOfBlock(block, 'STRING1'),
                contains: this.descendInputOfBlock(block, 'STRING2')
            };
        case 'operator_divide':
            return {
                kind: ReporterOpcode.OP_DIVIDE,
                left: this.descendInputOfBlock(block, 'NUM1'),
                right: this.descendInputOfBlock(block, 'NUM2')
            };
        case 'operator_equals':
            return {
                kind: ReporterOpcode.OP_EQUALS,
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            };
        case 'operator_gt':
            return {
                kind: ReporterOpcode.OP_GREATER,
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            };
        case 'operator_join':
            return {
                kind: ReporterOpcode.OP_JOIN,
                left: this.descendInputOfBlock(block, 'STRING1'),
                right: this.descendInputOfBlock(block, 'STRING2')
            };
        case 'operator_length':
            return {
                kind: ReporterOpcode.OP_LENGTH,
                string: this.descendInputOfBlock(block, 'STRING')
            };
        case 'operator_letter_of':
            return {
                kind: ReporterOpcode.OP_LETTER_OF,
                letter: this.descendInputOfBlock(block, 'LETTER'),
                string: this.descendInputOfBlock(block, 'STRING')
            };
        case 'operator_lt':
            return {
                kind: ReporterOpcode.OP_LESS,
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            };
        case 'operator_mathop': {
            const value = this.descendInputOfBlock(block, 'NUM');
            const operator = block.fields.OPERATOR.value.toLowerCase();
            switch (operator) {
            case 'abs': return {
                kind: ReporterOpcode.OP_ABS,
                value
            };
            case 'floor': return {
                kind: ReporterOpcode.OP_FLOOR,
                value
            };
            case 'ceiling': return {
                kind: ReporterOpcode.OP_CEILING,
                value
            };
            case 'sqrt': return {
                kind: ReporterOpcode.OP_SQRT,
                value
            };
            case 'sin': return {
                kind: ReporterOpcode.OP_SIN,
                value
            };
            case 'cos': return {
                kind: ReporterOpcode.OP_COS,
                value
            };
            case 'tan': return {
                kind: ReporterOpcode.OP_TAN,
                value
            };
            case 'asin': return {
                kind: ReporterOpcode.OP_ASIN,
                value
            };
            case 'acos': return {
                kind: ReporterOpcode.OP_ACOS,
                value
            };
            case 'atan': return {
                kind: ReporterOpcode.OP_ATAN,
                value
            };
            case 'ln': return {
                kind: ReporterOpcode.OP_LOG_E,
                value
            };
            case 'log': return {
                kind: ReporterOpcode.OP_LOG_10,
                value
            };
            case 'e ^': return {
                kind: ReporterOpcode.OP_POW_E,
                value
            };
            case '10 ^': return {
                kind: ReporterOpcode.OP_POW_10,
                value
            };
            default: return {
                kind: ReporterOpcode.CONSTANT,
                value: 0
            };
            }
        }
        case 'operator_mod':
            return {
                kind: ReporterOpcode.OP_MOD,
                left: this.descendInputOfBlock(block, 'NUM1'),
                right: this.descendInputOfBlock(block, 'NUM2')
            };
        case 'operator_multiply':
            return {
                kind: ReporterOpcode.OP_MULTIPLY,
                left: this.descendInputOfBlock(block, 'NUM1'),
                right: this.descendInputOfBlock(block, 'NUM2')
            };
        case 'operator_not':
            return {
                kind: ReporterOpcode.OP_NOT,
                operand: this.descendInputOfBlock(block, 'OPERAND')
            };
        case 'operator_or':
            return {
                kind: ReporterOpcode.OP_OR,
                left: this.descendInputOfBlock(block, 'OPERAND1'),
                right: this.descendInputOfBlock(block, 'OPERAND2')
            };
        case 'operator_random': {
            const from = this.descendInputOfBlock(block, 'FROM');
            const to = this.descendInputOfBlock(block, 'TO');
            // If both values are known at compile time, we can do some optimizations.
            // TODO: move optimizations to jsgen?
            if (from.kind === ReporterOpcode.CONSTANT && to.kind === ReporterOpcode.CONSTANT) {
                const sFrom = from.value;
                const sTo = to.value;
                const nFrom = Cast.toNumber(sFrom);
                const nTo = Cast.toNumber(sTo);
                // If both numbers are the same, random is unnecessary.
                // todo: this probably never happens so consider removing
                if (nFrom === nTo) {
                    return {
                        kind: ReporterOpcode.CONSTANT,
                        value: nFrom
                    };
                }
                // If both are ints, hint this to the compiler
                if (Cast.isInt(sFrom) && Cast.isInt(sTo)) {
                    return {
                        kind: ReporterOpcode.OP_RANDOM,
                        low: nFrom <= nTo ? from : to,
                        high: nFrom <= nTo ? to : from,
                        useInts: true,
                        useFloats: false
                    };
                }
                // Otherwise hint that these are floats
                return {
                    kind: ReporterOpcode.OP_RANDOM,
                    low: nFrom <= nTo ? from : to,
                    high: nFrom <= nTo ? to : from,
                    useInts: false,
                    useFloats: true
                };
            } else if (from.kind === ReporterOpcode.CONSTANT) {
                // If only one value is known at compile-time, we can still attempt some optimizations.
                if (!Cast.isInt(Cast.toNumber(from.value))) {
                    return {
                        kind: ReporterOpcode.OP_RANDOM,
                        low: from,
                        high: to,
                        useInts: false,
                        useFloats: true
                    };
                }
            } else if (to.kind === ReporterOpcode.CONSTANT) {
                if (!Cast.isInt(Cast.toNumber(to.value))) {
                    return {
                        kind: ReporterOpcode.OP_RANDOM,
                        low: from,
                        high: to,
                        useInts: false,
                        useFloats: true
                    };
                }
            }
            // No optimizations possible
            return {
                kind: ReporterOpcode.OP_RANDOM,
                low: from,
                high: to,
                useInts: false,
                useFloats: false
            };
        }
        case 'operator_round':
            return {
                kind: ReporterOpcode.OP_ROUND,
                value: this.descendInputOfBlock(block, 'NUM')
            };
        case 'operator_subtract':
            return {
                kind: ReporterOpcode.OP_SUBTRACT,
                left: this.descendInputOfBlock(block, 'NUM1'),
                right: this.descendInputOfBlock(block, 'NUM2')
            };

        case 'sensing_answer':
            return {
                kind: ReporterOpcode.SENSING_ANSWER,
            };
        case 'sensing_coloristouchingcolor':
            return {
                kind: ReporterOpcode.SENSING_COLOR_TOUCHING_COLOR,
                target: this.descendInputOfBlock(block, 'COLOR2'),
                mask: this.descendInputOfBlock(block, 'COLOR')
            };
        case 'sensing_current':
            switch (block.fields.CURRENTMENU.value.toLowerCase()) {
            case 'year':
                return {
                    kind: ReporterOpcode.SENSING_TIME_YEAR,
                };
            case 'month':
                return {
                    kind: ReporterOpcode.SENSING_TIME_MONTH,
                };
            case 'date':
                return {
                    kind: ReporterOpcode.SENSING_TIME_DATE,
                };
            case 'dayofweek':
                return {
                    kind: ReporterOpcode.SENSING_TIME_WEEKDAY,
                };
            case 'hour':
                return {
                    kind: ReporterOpcode.SENSING_TIME_HOUR,
                };
            case 'minute':
                return {
                    kind: ReporterOpcode.SENSING_TIME_MINUTE,
                };
            case 'second':
                return {
                    kind: ReporterOpcode.SENSING_TIME_SECOND,
                };
            }
            return {
                kind: ReporterOpcode.CONSTANT,
                value: 0
            };
        case 'sensing_dayssince2000':
            return {
                kind: ReporterOpcode.SENSING_TIME_DAYS_SINCE_2000,
            };
        case 'sensing_distanceto':
            return {
                kind: ReporterOpcode.SENSING_DISTANCE,
                target: this.descendInputOfBlock(block, 'DISTANCETOMENU')
            };
        case 'sensing_keypressed':
            return {
                kind: ReporterOpcode.SENSING_KEY_DOWN,
                key: this.descendInputOfBlock(block, 'KEY_OPTION')
            };
        case 'sensing_mousedown':
            return {
                kind: ReporterOpcode.SENSING_MOUSE_DOWN,
            };
        case 'sensing_mousex':
            return {
                kind: ReporterOpcode.SENSING_MOUSE_X,
            };
        case 'sensing_mousey':
            return {
                kind: ReporterOpcode.SENSING_MOUSE_Y,
            };
        case 'sensing_of':
            return {
                kind: ReporterOpcode.SENSING_OF,
                property: block.fields.PROPERTY.value,
                object: this.descendInputOfBlock(block, 'OBJECT')
            };
        case 'sensing_timer':
            this.usesTimer = true;
            return {
                kind: ReporterOpcode.SENSING_TIMER_GET,
            };
        case 'sensing_touchingcolor':
            return {
                kind: ReporterOpcode.SENSING_TOUCHING_COLOR,
                color: this.descendInputOfBlock(block, 'COLOR')
            };
        case 'sensing_touchingobject':
            return {
                kind: ReporterOpcode.SENSING_TOUCHING_OBJECT,
                object: this.descendInputOfBlock(block, 'TOUCHINGOBJECTMENU')
            };
        case 'sensing_username':
            return {
                kind: ReporterOpcode.SENSING_USERNAME,
            };

        case 'sound_sounds_menu':
            // This menu is special compared to other menus -- it actually has an opcode function.
            return {
                kind: ReporterOpcode.CONSTANT,
                value: block.fields.SOUND_MENU.value
            };

        case 'tw_getLastKeyPressed':
            return {
                kind: ReporterOpcode.TW_KEY_LAST_PRESSED,
            };

        default: {
            const opcodeFunction = this.runtime.getOpcodeFunction(block.opcode);
            if (opcodeFunction) {
                // It might be a non-compiled primitive from a standard category
                if (compatBlocks.inputs.includes(block.opcode)) {
                    return this.descendCompatLayer(block);
                }
                // It might be an extension block.
                const blockInfo = this.getBlockInfo(block.opcode);
                if (blockInfo) {
                    const type = blockInfo.info.blockType;
                    if (type === BlockType.REPORTER || type === BlockType.BOOLEAN) {
                        return this.descendCompatLayer(block);
                    }
                }
            }

            // It might be a menu.
            const inputs = Object.keys(block.inputs);
            const fields = Object.keys(block.fields);
            if (inputs.length === 0 && fields.length === 1) {
                return {
                    kind: ReporterOpcode.CONSTANT,
                    value: block.fields[fields[0]].value
                };
            }

            log.warn(`IR: Unknown input: ${block.opcode}`, block);
            throw new Error(`IR: Unknown input: ${block.opcode}`);
        }
        }
    }

    /**
     * Descend into a stacked block. (eg. "move ( ) steps")
     * @param {*} block The Scratch block to parse.
     * @private
     * @returns {Node} Compiled node for this block.
     */
    descendStackedBlock (block) {
        switch (block.opcode) {
        case 'control_all_at_once':
            // In Scratch 3, this block behaves like "if 1 = 1"
            return {
                kind: BlockOpcode.CONTROL_IF_ELSE,
                condition: {
                    kind: ReporterOpcode.CONSTANT,
                    value: true
                },
                whenTrue: this.descendSubstack(block, 'SUBSTACK'),
                whenFalse: []
            };
        case 'control_create_clone_of':
            return {
                kind: BlockOpcode.CONTROL_CLONE_CREATE,
                target: this.descendInputOfBlock(block, 'CLONE_OPTION')
            };
        case 'control_delete_this_clone':
            this.script.yields = true;
            return {
                kind: BlockOpcode.CONTROL_CLONE_DELETE
            };
        case 'control_forever':
            this.analyzeLoop();
            return {
                kind: BlockOpcode.CONTROL_WHILE,
                condition: {
                    kind: ReporterOpcode.CONSTANT,
                    value: true
                },
                do: this.descendSubstack(block, 'SUBSTACK')
            };
        case 'control_for_each':
            this.analyzeLoop();
            return {
                kind: BlockOpcode.CONTROL_FOR,
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE),
                count: this.descendInputOfBlock(block, 'VALUE'),
                do: this.descendSubstack(block, 'SUBSTACK')
            };
        case 'control_if':
            return {
                kind: BlockOpcode.CONTROL_IF_ELSE,
                condition: this.descendInputOfBlock(block, 'CONDITION'),
                whenTrue: this.descendSubstack(block, 'SUBSTACK'),
                whenFalse: []
            };
        case 'control_if_else':
            return {
                kind: BlockOpcode.CONTROL_IF_ELSE,
                condition: this.descendInputOfBlock(block, 'CONDITION'),
                whenTrue: this.descendSubstack(block, 'SUBSTACK'),
                whenFalse: this.descendSubstack(block, 'SUBSTACK2')
            };
        case 'control_repeat':
            this.analyzeLoop();
            return {
                kind: BlockOpcode.CONTROL_REPEAT,
                times: this.descendInputOfBlock(block, 'TIMES'),
                do: this.descendSubstack(block, 'SUBSTACK')
            };
        case 'control_repeat_until': {
            this.analyzeLoop();
            // Dirty hack: automatically enable warp timer for this block if it uses timer
            // This fixes project that do things like "repeat until timer > 0.5"
            this.usesTimer = false;
            const condition = this.descendInputOfBlock(block, 'CONDITION');
            const needsWarpTimer = this.usesTimer;
            if (needsWarpTimer) {
                this.script.yields = true;
            }
            return {
                kind: BlockOpcode.CONTROL_WHILE,
                condition: {
                    kind: ReporterOpcode.OP_NOT,
                    operand: condition
                },
                do: this.descendSubstack(block, 'SUBSTACK'),
                warpTimer: needsWarpTimer
            };
        }
        case 'control_stop': {
            const level = block.fields.STOP_OPTION.value;
            if (level === 'all') {
                this.script.yields = true;
                return {
                    kind: BlockOpcode.CONTROL_STOP_ALL
                };
            } else if (level === 'other scripts in sprite' || level === 'other scripts in stage') {
                return {
                    kind: BlockOpcode.CONTROL_STOP_OTHERS
                };
            } else if (level === 'this script') {
                return {
                    kind: BlockOpcode.CONTROL_STOP_SCRIPT
                };
            }
            return {
                kind: BlockOpcode.NOP
            };
        }
        case 'control_wait':
            this.script.yields = true;
            return {
                kind: BlockOpcode.CONTROL_WAIT,
                seconds: this.descendInputOfBlock(block, 'DURATION')
            };
        case 'control_wait_until':
            this.script.yields = true;
            return {
                kind: BlockOpcode.CONTROL_WAIT_UNTIL,
                condition: this.descendInputOfBlock(block, 'CONDITION')
            };
        case 'control_while':
            this.analyzeLoop();
            return {
                kind: BlockOpcode.CONTROL_WHILE,
                condition: this.descendInputOfBlock(block, 'CONDITION'),
                do: this.descendSubstack(block, 'SUBSTACK'),
                // We should consider analyzing this like we do for control_repeat_until
                warpTimer: false
            };

        case 'data_addtolist':
            return {
                kind: BlockOpcode.LIST_ADD,
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                item: this.descendInputOfBlock(block, 'ITEM')
            };
        case 'data_changevariableby': {
            const variable = this.descendVariable(block, 'VARIABLE', SCALAR_TYPE);
            return {
                kind: BlockOpcode.VAR_SET,
                variable,
                value: {
                    kind: ReporterOpcode.OP_ADD,
                    left: {
                        kind: ReporterOpcode.VAR_GET,
                        variable
                    },
                    right: this.descendInputOfBlock(block, 'VALUE')
                }
            };
        }
        case 'data_deletealloflist':
            return {
                kind: BlockOpcode.LIST_DELETE_ALL,
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            };
        case 'data_deleteoflist': {
            const index = this.descendInputOfBlock(block, 'INDEX');
            if (index.kind === ReporterOpcode.CONSTANT && index.value === 'all') {
                return {
                    kind: BlockOpcode.LIST_DELETE_ALL,
                    list: this.descendVariable(block, 'LIST', LIST_TYPE)
                };
            }
            return {
                kind: BlockOpcode.LIST_DELETE,
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: index
            };
        }
        case 'data_hidelist':
            return {
                kind: BlockOpcode.LIST_HIDE,
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            };
        case 'data_hidevariable':
            return {
                kind: BlockOpcode.VAR_HIDE,
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
            };
        case 'data_insertatlist':
            return {
                kind: BlockOpcode.LIST_INSERT,
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: this.descendInputOfBlock(block, 'INDEX'),
                item: this.descendInputOfBlock(block, 'ITEM')
            };
        case 'data_replaceitemoflist':
            return {
                kind: BlockOpcode.LIST_REPLACE,
                list: this.descendVariable(block, 'LIST', LIST_TYPE),
                index: this.descendInputOfBlock(block, 'INDEX'),
                item: this.descendInputOfBlock(block, 'ITEM')
            };
        case 'data_setvariableto':
            return {
                kind: BlockOpcode.VAR_SET,
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE),
                value: this.descendInputOfBlock(block, 'VALUE')
            };
        case 'data_showlist':
            return {
                kind: BlockOpcode.LIST_SHOW,
                list: this.descendVariable(block, 'LIST', LIST_TYPE)
            };
        case 'data_showvariable':
            return {
                kind: BlockOpcode.VAR_SHOW,
                variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
            };

        case 'event_broadcast':
            return {
                kind: BlockOpcode.EVENT_BROADCAST,
                broadcast: this.descendInputOfBlock(block, 'BROADCAST_INPUT')
            };
        case 'event_broadcastandwait':
            this.script.yields = true;
            return {
                kind: BlockOpcode.EVENT_BROADCAST_AND_WAIT,
                broadcast: this.descendInputOfBlock(block, 'BROADCAST_INPUT')
            };

        case 'looks_changeeffectby':
            return {
                kind: BlockOpcode.LOOKS_EFFECT_CHANGE,
                effect: block.fields.EFFECT.value.toLowerCase(),
                value: this.descendInputOfBlock(block, 'CHANGE')
            };
        case 'looks_changesizeby':
            return {
                kind: BlockOpcode.LOOKS_SIZE_CHANGE,
                size: this.descendInputOfBlock(block, 'CHANGE')
            };
        case 'looks_cleargraphiceffects':
            return {
                kind: BlockOpcode.LOOKS_EFFECT_CLEAR,
            };
        case 'looks_goforwardbackwardlayers':
            if (block.fields.FORWARD_BACKWARD.value === 'forward') {
                return {
                    kind: BlockOpcode.LOOKS_LAYER_FORWARD,
                    layers: this.descendInputOfBlock(block, 'NUM')
                };
            }
            return {
                kind: BlockOpcode.LOOKS_LAYER_BACKWARD,
                layers: this.descendInputOfBlock(block, 'NUM')
            };
        case 'looks_gotofrontback':
            if (block.fields.FRONT_BACK.value === 'front') {
                return {
                    kind: BlockOpcode.LOOKS_LAYER_FRONT
                };
            }
            return {
                kind: BlockOpcode.LOOKS_LAYER_BACK
            };
        case 'looks_hide':
            return {
                kind: BlockOpcode.LOOKS_HIDE
            };
        case 'looks_nextbackdrop':
            return {
                kind: BlockOpcode.LOOKS_BACKDROP_NEXT
            };
        case 'looks_nextcostume':
            return {
                kind: BlockOpcode.LOOKS_COSTUME_NEXT
            };
        case 'looks_seteffectto':
            return {
                kind: BlockOpcode.LOOKS_EFFECT_SET,
                effect: block.fields.EFFECT.value.toLowerCase(),
                value: this.descendInputOfBlock(block, 'VALUE')
            };
        case 'looks_setsizeto':
            return {
                kind: BlockOpcode.LOOKS_SIZE_SET,
                size: this.descendInputOfBlock(block, 'SIZE')
            };
        case 'looks_show':
            return {
                kind: BlockOpcode.LOOKS_SHOW
            };
        case 'looks_switchbackdropto':
            return {
                kind: BlockOpcode.LOOKS_BACKDROP_SET,
                backdrop: this.descendInputOfBlock(block, 'BACKDROP')
            };
        case 'looks_switchcostumeto':
            return {
                kind: BlockOpcode.LOOKS_COSTUME_SET,
                costume: this.descendInputOfBlock(block, 'COSTUME')
            };

        case 'motion_changexby':
            return {
                kind: BlockOpcode.MOTION_X_CHANGE,
                dx: this.descendInputOfBlock(block, 'DX')
            };
        case 'motion_changeyby':
            return {
                kind: BlockOpcode.MOTION_Y_CHANGE,
                dy: this.descendInputOfBlock(block, 'DY')
            };
        case 'motion_gotoxy':
            return {
                kind: BlockOpcode.MOTION_XY_SET,
                x: this.descendInputOfBlock(block, 'X'),
                y: this.descendInputOfBlock(block, 'Y')
            };
        case 'motion_ifonedgebounce':
            return {
                kind: BlockOpcode.MOTION_IF_ON_EDGE_BOUNCE,
            };
        case 'motion_movesteps':
            return {
                kind: BlockOpcode.MOTION_STEP,
                steps: this.descendInputOfBlock(block, 'STEPS')
            };
        case 'motion_pointindirection':
            return {
                kind: BlockOpcode.MOTION_DIRECTION_SET,
                direction: this.descendInputOfBlock(block, 'DIRECTION')
            };
        case 'motion_setrotationstyle':
            return {
                kind: BlockOpcode.MOTION_ROTATION_STYLE_SET,
                style: block.fields.STYLE.value
            };
        case 'motion_setx':
            return {
                kind: BlockOpcode.MOTION_X_SET,
                x: this.descendInputOfBlock(block, 'X')
            };
        case 'motion_sety':
            return {
                kind: BlockOpcode.MOTION_Y_SET,
                y: this.descendInputOfBlock(block, 'Y')
            };
        case 'motion_turnleft':
            return {
                kind: BlockOpcode.MOTION_DIRECTION_SET,
                direction: {
                    kind: ReporterOpcode.OP_SUBTRACT,
                    left: {
                        kind: ReporterOpcode.MOTION_DIRECTION_GET,
                    },
                    right: this.descendInputOfBlock(block, 'DEGREES')
                }
            };
        case 'motion_turnright':
            return {
                kind: BlockOpcode.MOTION_DIRECTION_SET,
                direction: {
                    kind: ReporterOpcode.OP_ADD,
                    left: {
                        kind: ReporterOpcode.MOTION_DIRECTION_GET,
                    },
                    right: this.descendInputOfBlock(block, 'DEGREES')
                }
            };

        case 'pen_clear':
            return {
                kind: BlockOpcode.PEN_CLEAR
            };
        case 'pen_changePenColorParamBy':
            return {
                kind: BlockOpcode.PEN_COLOR_PARAM_CHANGE,
                param: this.descendInputOfBlock(block, 'COLOR_PARAM'),
                value: this.descendInputOfBlock(block, 'VALUE')
            };
        case 'pen_changePenHueBy':
            return {
                kind: BlockOpcode.PEN_COLOR_HUE_CHANGE_LEGACY,
                hue: this.descendInputOfBlock(block, 'HUE')
            };
        case 'pen_changePenShadeBy':
            return {
                kind: BlockOpcode.PEN_COLOR_SHADE_CHANGE_LEGACY,
                shade: this.descendInputOfBlock(block, 'SHADE')
            };
        case 'pen_penDown':
            return {
                kind: BlockOpcode.PEN_DOWN
            };
        case 'pen_penUp':
            return {
                kind: BlockOpcode.PEN_UP
            };
        case 'pen_setPenColorParamTo':
            return {
                kind: BlockOpcode.PEN_COLOR_PARAM_SET,
                param: this.descendInputOfBlock(block, 'COLOR_PARAM'),
                value: this.descendInputOfBlock(block, 'VALUE')
            };
        case 'pen_setPenColorToColor':
            return {
                kind: BlockOpcode.PEN_COLOR_SET,
                color: this.descendInputOfBlock(block, 'COLOR')
            };
        case 'pen_setPenHueToNumber':
            return {
                kind: BlockOpcode.PEN_COLOR_HUE_SET_LEGACY,
                hue: this.descendInputOfBlock(block, 'HUE')
            };
        case 'pen_setPenShadeToNumber':
            return {
                kind: BlockOpcode.PEN_COLOR_SHADE_SET_LEGACY,
                shade: this.descendInputOfBlock(block, 'SHADE')
            };
        case 'pen_setPenSizeTo':
            return {
                kind: BlockOpcode.PEN_SIZE_SET,
                size: this.descendInputOfBlock(block, 'SIZE')
            };
        case 'pen_changePenSizeBy':
            return {
                kind: BlockOpcode.PEN_SIZE_CHANGE,
                size: this.descendInputOfBlock(block, 'SIZE')
            };
        case 'pen_stamp':
            return {
                kind: BlockOpcode.PEN_STAMP
            };

        case 'procedures_call': {
            // setting of yields will be handled later in the analysis phase

            const procedureCode = block.mutation.proccode;
            if (procedureCode === 'tw:debugger;') {
                return {
                    kind: BlockOpcode.DEBUGGER
                };
            }
            const paramNamesIdsAndDefaults = this.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
            if (paramNamesIdsAndDefaults === null) {
                return {
                    kind: BlockOpcode.NOP
                };
            }

            const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults;

            const addonBlock = this.runtime.getAddonBlock(procedureCode);
            if (addonBlock) {
                this.script.yields = true;
                const args = {};
                for (let i = 0; i < paramIds.length; i++) {
                    let value;
                    if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
                        value = this.descendInputOfBlock(block, paramIds[i]);
                    } else {
                        value = {
                            kind: ReporterOpcode.CONSTANT,
                            value: paramDefaults[i]
                        };
                    }
                    args[paramNames[i]] = value;
                }
                return {
                    kind: BlockOpcode.ADDON_CALL,
                    code: procedureCode,
                    arguments: args,
                    blockId: block.id
                };
            }

            const definitionId = this.blocks.getProcedureDefinition(procedureCode);
            const definitionBlock = this.blocks.getBlock(definitionId);
            if (!definitionBlock) {
                return {
                    kind: BlockOpcode.NOP
                };
            }
            const innerDefinition = this.blocks.getBlock(definitionBlock.inputs.custom_block.block);

            let isWarp = this.script.isWarp;
            if (!isWarp) {
                if (innerDefinition && innerDefinition.mutation) {
                    const warp = innerDefinition.mutation.warp;
                    if (typeof warp === 'boolean') {
                        isWarp = warp;
                    } else if (typeof warp === 'string') {
                        isWarp = JSON.parse(warp);
                    }
                }
            }

            const variant = generateProcedureVariant(procedureCode, isWarp);

            if (!this.script.dependedProcedures.includes(variant)) {
                this.script.dependedProcedures.push(variant);
            }

            // Non-warp direct recursion yields.
            if (!this.script.isWarp) {
                if (procedureCode === this.script.procedureCode) {
                    this.script.yields = true;
                }
            }

            const args = [];
            for (let i = 0; i < paramIds.length; i++) {
                let value;
                if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
                    value = this.descendInputOfBlock(block, paramIds[i]);
                } else {
                    value = {
                        kind: ReporterOpcode.CONSTANT,
                        value: paramDefaults[i]
                    };
                }
                args.push(value);
            }

            return {
                kind: BlockOpcode.PROCEDURE_CALL,
                code: procedureCode,
                variant,
                arguments: args
            };
        }

        case 'sensing_resettimer':
            return {
                kind: BlockOpcode.SENSING_TIMER_RESET
            };

        default: {
            const opcodeFunction = this.runtime.getOpcodeFunction(block.opcode);
            if (opcodeFunction) {
                // It might be a non-compiled primitive from a standard category
                if (compatBlocks.stacked.includes(block.opcode)) {
                    return this.descendCompatLayer(block);
                }
                // It might be an extension block.
                const blockInfo = this.getBlockInfo(block.opcode);
                if (blockInfo) {
                    const type = blockInfo.info.blockType;
                    if (type === BlockType.COMMAND) {
                        return this.descendCompatLayer(block);
                    }
                }
            }

            // When this thread was triggered by a stack click, attempt to compile as an input.
            // TODO: perhaps this should be moved to generate()?
            if (this.thread.stackClick) {
                try {
                    const inputNode = this.descendInput(block);
                    return {
                        kind: BlockOpcode.VISUAL_REPORT,
                        input: inputNode
                    };
                } catch (e) {
                    // Ignore
                }
            }

            log.warn(`IR: Unknown stacked block: ${block.opcode}`, block);
            throw new Error(`IR: Unknown stacked block: ${block.opcode}`);
        }
        }
    }

    /**
     * Descend into a stack of blocks (eg. the blocks contained within an "if" block)
     * @param {*} parentBlock The parent Scratch block that contains the stack to parse.
     * @param {*} substackName The name of the stack to descend into.
     * @private
     * @returns {Node[]} List of stacked block nodes.
     */
    descendSubstack (parentBlock, substackName) {
        const input = parentBlock.inputs[substackName];
        if (!input) {
            return [];
        }
        const stackId = input.block;
        return this.walkStack(stackId);
    }

    /**
     * Descend into and walk the siblings of a stack.
     * @param {string} startingBlockId The ID of the first block of a stack.
     * @private
     * @returns {Node[]} List of stacked block nodes.
     */
    walkStack (startingBlockId) {
        const result = [];
        let blockId = startingBlockId;

        while (blockId !== null) {
            const block = this.getBlockById(blockId);
            if (!block) {
                break;
            }

            const node = this.descendStackedBlock(block);
            result.push(node);

            blockId = block.next;
        }

        return result;
    }

    /**
     * Descend into a variable.
     * @param {*} block The block that has the variable.
     * @param {string} fieldName The name of the field that the variable is stored in.
     * @param {''|'list'} type Variable type, '' for scalar and 'list' for list.
     * @private
     * @returns {*} A parsed variable object.
     */
    descendVariable (block, fieldName, type) {
        const variable = block.fields[fieldName];
        const id = variable.id;

        if (this.variableCache.hasOwnProperty(id)) {
            return this.variableCache[id];
        }

        const data = this._descendVariable(id, variable.value, type);
        this.variableCache[id] = data;
        return data;
    }

    /**
     * @param {string} id The ID of the variable.
     * @param {string} name The name of the variable.
     * @param {''|'list'} type The variable type.
     * @private
     * @returns {*} A parsed variable object.
     */
    _descendVariable (id, name, type) {
        const target = this.target;
        const stage = this.stage;

        // Look for by ID in target...
        if (target.variables.hasOwnProperty(id)) {
            return createVariableData('target', target.variables[id]);
        }

        // Look for by ID in stage...
        if (!target.isStage) {
            if (stage && stage.variables.hasOwnProperty(id)) {
                return createVariableData('stage', stage.variables[id]);
            }
        }

        // Look for by name and type in target...
        for (const varId in target.variables) {
            if (target.variables.hasOwnProperty(varId)) {
                const currVar = target.variables[varId];
                if (currVar.name === name && currVar.type === type) {
                    return createVariableData('target', currVar);
                }
            }
        }

        // Look for by name and type in stage...
        if (!target.isStage && stage) {
            for (const varId in stage.variables) {
                if (stage.variables.hasOwnProperty(varId)) {
                    const currVar = stage.variables[varId];
                    if (currVar.name === name && currVar.type === type) {
                        return createVariableData('stage', currVar);
                    }
                }
            }
        }

        // Create it locally...
        const newVariable = new Variable(id, name, type, false);
        target.variables[id] = newVariable;

        if (target.sprite) {
            // Create the variable in all instances of this sprite.
            // This is necessary because the script cache is shared between clones.
            // sprite.clones has all instances of this sprite including the original and all clones
            for (const clone of target.sprite.clones) {
                if (!clone.variables.hasOwnProperty(id)) {
                    clone.variables[id] = new Variable(id, name, type, false);
                }
            }
        }

        return createVariableData('target', newVariable);
    }

    /**
     * Descend into a block that uses the compatibility layer.
     * @param {*} block The block to use the compatibility layer for.
     * @private
     * @returns {Node} The parsed node.
     */
    descendCompatLayer (block) {
        this.script.yields = true;
        const inputs = {};
        const fields = {};
        for (const name of Object.keys(block.inputs)) {
            inputs[name] = this.descendInputOfBlock(block, name);
        }
        for (const name of Object.keys(block.fields)) {
            fields[name] = block.fields[name].value;
        }
        return {
            kind: BlockOpcode.COMPATIBILITY_LAYER,
            opcode: block.opcode,
            inputs,
            fields
        };
    }

    analyzeLoop () {
        if (!this.script.isWarp || this.script.warpTimer) {
            this.script.yields = true;
        }
    }

    readTopBlockComment (commentId) {
        const comment = this.target.comments[commentId];
        if (!comment) {
            // can't find the comment
            // this is safe to ignore
            return;
        }

        const text = comment.text;

        for (const line of text.split('\n')) {
            if (!/^tw\b/.test(line)) {
                continue;
            }

            const flags = line.split(' ');
            for (const flag of flags) {
                switch (flag) {
                case 'nocompile':
                    throw new Error('Script explicitly disables compilation');
                case 'stuck':
                    this.script.warpTimer = true;
                    break;
                }
            }

            // Only the first 'tw' line is parsed.
            break;
        }
    }

    /**
     * @param {string} topBlockId The ID of the top block of the script.
     * @returns {IntermediateScript}
     */
    generate (topBlockId) {
        this.blocks.populateProcedureCache();

        this.script.topBlockId = topBlockId;

        const topBlock = this.getBlockById(topBlockId);
        if (!topBlock) {
            if (this.script.isProcedure) {
                // Empty procedure
                return this.script;
            }
            throw new Error('Cannot find top block');
        }

        if (topBlock.comment) {
            this.readTopBlockComment(topBlock.comment);
        }

        // If the top block is a hat, advance to its child.
        let entryBlock;
        if (this.runtime.getIsHat(topBlock.opcode) || topBlock.opcode === 'procedures_definition') {
            if (this.runtime.getIsEdgeActivatedHat(topBlock.opcode)) {
                throw new Error(`Not compiling an edge-activated hat: ${topBlock.opcode}`);
            }
            entryBlock = topBlock.next;
        } else {
            entryBlock = topBlockId;
        }

        if (!entryBlock) {
            // This is an empty script.
            return this.script;
        }

        this.script.stack = this.walkStack(entryBlock);

        return this.script;
    }
}

class IRGenerator {
    constructor (thread) {
        this.thread = thread;
        this.blocks = thread.blockContainer;

        this.proceduresToCompile = new Map();
        this.compilingProcedures = new Map();
        /** @type {Object.<string, IntermediateScript>} */
        this.procedures = {};

        this.analyzedProcedures = [];
    }

    addProcedureDependencies (dependencies) {
        for (const procedureVariant of dependencies) {
            if (this.procedures.hasOwnProperty(procedureVariant)) {
                continue;
            }
            if (this.compilingProcedures.has(procedureVariant)) {
                continue;
            }
            if (this.proceduresToCompile.has(procedureVariant)) {
                continue;
            }
            const procedureCode = parseProcedureCode(procedureVariant);
            const definition = this.blocks.getProcedureDefinition(procedureCode);
            this.proceduresToCompile.set(procedureVariant, definition);
        }
    }

    /**
     * @param {ScriptTreeGenerator} generator The generator to run.
     * @param {string} topBlockId The ID of the top block in the stack.
     * @returns {IntermediateScript} Intermediate script.
     */
    generateScriptTree (generator, topBlockId) {
        const result = generator.generate(topBlockId);
        this.addProcedureDependencies(result.dependedProcedures);
        return result;
    }

    /**
     * Recursively analyze a script and its dependencies.
     * @param {IntermediateScript} script Intermediate script.
     */
    analyzeScript (script) {
        let madeChanges = false;
        for (const procedureCode of script.dependedProcedures) {
            const procedureData = this.procedures[procedureCode];

            // Analyze newly found procedures.
            if (!this.analyzedProcedures.includes(procedureCode)) {
                this.analyzedProcedures.push(procedureCode);
                if (this.analyzeScript(procedureData)) {
                    madeChanges = true;
                }
                this.analyzedProcedures.pop();
            }

            // If a procedure used by a script may yield, the script itself may yield.
            if (procedureData.yields && !script.yields) {
                script.yields = true;
                madeChanges = true;
            }
        }
        return madeChanges;
    }

    /**
     * @returns {IntermediateRepresentation} Intermediate representation.
     */
    generate () {
        const entry = this.generateScriptTree(new ScriptTreeGenerator(this.thread), this.thread.topBlock);

        // Compile any required procedures.
        // As procedures can depend on other procedures, this process may take several iterations.
        const procedureTreeCache = this.blocks._cache.compiledProcedures;
        while (this.proceduresToCompile.size > 0) {
            this.compilingProcedures = this.proceduresToCompile;
            this.proceduresToCompile = new Map();

            for (const [procedureVariant, definitionId] of this.compilingProcedures.entries()) {
                if (procedureTreeCache[procedureVariant]) {
                    const result = procedureTreeCache[procedureVariant];
                    this.procedures[procedureVariant] = result;
                    this.addProcedureDependencies(result.dependedProcedures);
                } else {
                    const isWarp = parseIsWarp(procedureVariant);
                    const generator = new ScriptTreeGenerator(this.thread);
                    generator.setProcedureVariant(procedureVariant);
                    if (isWarp) generator.enableWarp();
                    const compiledProcedure = this.generateScriptTree(generator, definitionId);
                    this.procedures[procedureVariant] = compiledProcedure;
                    procedureTreeCache[procedureVariant] = compiledProcedure;
                }
            }
        }

        // Analyze scripts until no changes are made.
        while (this.analyzeScript(entry));

        const ir = new IntermediateRepresentation();
        ir.entry = entry;
        ir.procedures = this.procedures;
        return ir;
    }
}

module.exports = IRGenerator;
